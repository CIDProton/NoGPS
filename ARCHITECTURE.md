# NoGPS Architecture

## Цель разделения
Проект разделён на два независимых слоя:
- **Core (ядро)**: алгоритмы позиционирования, карты признаков и ограничение памяти.
- **Simulator (симулятор)**: визуализация, управление, генерация лидара и карта стен.

Это нужно, чтобы позже портировать только `core` на ARM/Linux, а симулятор оставить как dev-инструмент под Windows.

## Текущая структура
- `nogps_core.hpp`, `nogps_core.cpp` — чистая логика ядра без WinAPI.
- `simulator_gdi.hpp`, `simulator_gdi.cpp` — WinAPI/GDI визуализация и цикл симуляции.
- `main.cpp` — тонкая точка входа, запускающая симулятор.

## Контракт между слоями
Симулятор передаёт в ядро:
- `dt`
- `scan` (`std::vector<LidarPoint>`)
- `imuVelocity`

Ядро возвращает:
- `velocityCommand` (рефлекторный отталкивающий вектор)
- текущие debug-линии (`getDebugLines`)
- граф памяти (`getGraph`)
- оценку положения (`getEstPos`)
- текстовые логи (`getLogs`)

## Ключевой фикс отображения
Ранее правая панель просто отрисовывала мировые координаты с X-сдвигом `+640`. Из-за этого граф быстро уезжал за границы правой панели.

Теперь введено преобразование `toCoreView(...)`:
- центр правой панели всегда привязан к `core.getEstPos()`;
- всё отображение ядра рисуется в локальной системе координат относительно дрона;
- добавлен масштаб `kCoreViewScale` для лучшей читаемости.

## Ограничения
- Симулятор использует WinAPI/GDI и компилируется под Windows.
- Ядро пока работает в 2D (ось `z=0`).
- Нет физики столкновений по геометрии корпуса — только рефлекс от лидара.
- Нет постоянного хранилища offload-данных: только логический флаг и очистка RAM-полей.
