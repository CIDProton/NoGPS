from client2server import client2server
import time

class tracker:
    def __init__(self):
        # Инициализируем память для расчета скорости движения цели
        self.last_dx = 0
        self.last_time = time.time()
        
        # Коэффициенты настройки (нужно подбирать под физику твоего радара)
        self.Kp = 0.90   # Пропорциональный (реакция на ошибку) - чуть увеличил для резкости
        self.Kd = 0.4   # Дифференциальный (упреждение/скорость) - ЭТО ГЛАВНОЕ ДЛЯ ОПЕРЕЖЕНИЯ
        self.min_move = 3 # Минимальный шаг, чтобы не было застоя

    def run(self, tracklog):
        c2s = client2server()
        
        while True:
            status = c2s.getStatus()
            
            # 1. Декодирование DX (осталось без изменений, логика верная)
            dx = int(status) & 0x0fff
            if dx > 2048:
                dx = dx - 4096
            
            # 2. Расчет времени прошедшего с последнего кадра (для точной скорости)
            current_time = time.time()
            dt = current_time - self.last_time
            if dt == 0: dt = 0.01 # Защита от деления на ноль

            # 3. Вычисление скорости изменения ошибки (Производная)
            # Если dx быстро растет, значит цель убегает, нужно ускоряться
            derivative = (dx - self.last_dx) / dt
            
            # 4. Формула ПД-регулятора с упреждением
            # Мы добавляем к реакции на ошибку (dx) реакцию на скорость (derivative)
            # Это заставляет радар двигаться быстрее, если цель убегает
            k = int((abs(dx) * self.Kp) + (abs(derivative) * self.Kd) + self.min_move)
            
            # Ограничение максимального шага (чтобы не сорвало башню при шуме)
            if k > 75: 
                k = 75

            # 5. Логика движения (направление оставил как в оригинале)
            # Убрал жесткий порог 500, так как для узкого луча нужна плавность везде
            if dx > 0:
                c2s.moveLeft(k)
            elif dx < 0:
                c2s.moveRight(k)
            
            # Если dx == 0, ничего не делаем (или можно отправлять 0, зависит от API)

            # 6. Сохраняем состояние для следующего цикла
            self.last_dx = dx
            self.last_time = current_time
            